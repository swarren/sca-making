/*
 * Copyright (c) 2018 Stephen Warren
 *
 * Derived from code:
 * Copyright (c) 2013 Danny Havenith
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <avr/io.h>
#include <util/delay.h>

#define WS2811_PORT	PORTB
#define CHANNEL		4

void reset(void) {
	WS2811_PORT = 0;
	_delay_loop_1(250);
}

#if (F_CPU == 8000000)
// ATTiny85
static void send(uint8_t val)
{
	const uint8_t low_val = 0;
	const uint8_t high_val = _BV(CHANNEL);
	uint8_t bits = 8;

	asm volatile(
		"bit:									\n\t"
		"		out		%[portout], %[low_val]	\n\t"
		"		lsl		%[val]					\n\t"
		"		out		%[portout], %[high_val]	\n\t"
		"		brcs	isone					\n\t"
		"		out		%[portout], %[low_val]	\n\t"
		"isone:									\n\t"
		"		subi	%[bits], 1				\n\t"
		"		brne	bit						\n\t"
		"		out		%[portout], %[low_val]	\n\t"
		"done:									\n\t"
		/*
		 * Either something is wrong with the constraints here, or the
		 * compiler is buggy; if CHANNEL==3, _BV(CHANNEL)==8, which is the
		 * same as the initial value of bits, so both bits and high_val get
		 * assigned to the same register, and this code breaks horribly.
		 */
		: /* outputs */
		[val] "+r" (val),
		[bits] "+r" (bits)
		: /* inputs */
		[low_val] "r" (low_val),
		[high_val] "r" (high_val),
		[portout] "I" (_SFR_IO_ADDR(WS2811_PORT))
	);
}
#else
// ATTiny13/A
static void send(uint8_t val)
{
	const uint8_t low_val = 0;
	const uint8_t high_val = _BV(CHANNEL);
	uint8_t bits = 8;

	asm volatile(
			"bit:									\n\t"
			"		out		%[portout], %[high_val]	\n\t"
			"		lsl		%[val]					\n\t"
			"		brcs	isone					\n\t"
			"		out		%[portout], %[low_val]	\n\t"
			"isone:									\n\t"
			"		rjmp	common					\n\t"
			"common:								\n\t"
			"		subi	%[bits], 1				\n\t"
			"		brne	morebits				\n\t"
			"		out		%[portout], %[low_val]	\n\t"
			"		rjmp	done					\n\t"
			"morebits:								\n\t"
			"		out		%[portout], %[low_val]	\n\t"
			"		rjmp	bit						\n\t"
			"done:									\n\t"
		: /* outputs */
		[val] "+r" (val),
		[bits] "+r" (bits)
		: /* inputs */
		[low_val] "r" (low_val),
		[high_val] "r" (high_val),
		[portout] "I" (_SFR_IO_ADDR(WS2811_PORT))
	);
}
#endif

static void send8(uint8_t val) {
	reset();
	for (int led = 0; led < 8; led++) {
#if 0 // Yellow
		send((val / 2) + (val / 4));
		send(val);
		send(val / 16);
#elif 1 // Brighter yellow
		send(val);
		send(val);
		send(val / 8);
#else // Full
		send(val);
		send(val);
		send(val);
#endif
	}
}

int main()
{
	DDRB = _BV(CHANNEL);
	PORTB = _BV(CHANNEL);

	uint8_t prev_val = 0;
	for(;;) {
		uint8_t new_val = 100 + (rand() % 155);
		int16_t delta = (uint16_t)new_val - (uint16_t)prev_val;
		for (int i = 1; i < 10; i++) {
			uint16_t val = prev_val + ((delta * i) / 10);
			send8((uint8_t)val);
			_delay_ms(15);
		}
		prev_val = new_val;
	}
}
